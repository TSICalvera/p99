##Бинарные деревья

Бинарное дерево является либо пустым, либо состоит из родительского узла и двух потомков, являющихся также бинарными деревьями. 
В Прологе мы представляем пустое дерево термином 'nil', а непустое - t(X,L,R), 
где X - родительский узел, L и R - левый и правый наследники. 

![alt text](https://github.com/schastny/p99/raw/master/img/p67.gif)
Приведённое на картинке дерево может быть представлено следующей записью:    

    T1 = 
        t(
            a, 
            t(
                b, 
                t(d, nil, nil), 
                t(e, nil, nil)
            ), 
            t(  
                c, 
                nil, 
                t(
                    f, 
                    t(g, nil, nil), 
                    nil
                )
            )
        )

Другой пример - бинарное дерево, состоящее только из родительского узла:  

    T2 = t(a,nil,nil) 

или пустое дерево:

    T3 = nil

**4.01 (\*) 
Проверить, является ли данный объект бинарным деревом**  
Напишите предикат istree/1, который возвращает true только в том случае, если его аргумент - это бинарное дерево.  
Пример:

    ?- istree(t(a,t(b,nil,nil),nil)).
    Yes
    ?- istree(t(a,t(b,nil,nil))).
    No

**4.02 (\*\*) Построить сбалансированное двоичное дерево**  
В полностью сбалансированном двоичном дереве для всех узлов выполняется следующее условие:  
Количество узлов в левом и правом поддеревьях практически одинаково, 
что значит, их разница не может быть больше одного.  

Напишите метод cbal_tree/2 для построения полностью сбалансированного дерева с заданным количеством узлов. 
Метод должен возвращать все возможные варианты построения. 
Поместите символ 'x' в качестве значения во все узлы дерева.    
Пример:

    ?- cbal_tree(4,T).
    T = t(x, t(x, nil, nil), t(x, nil, t(x, nil, nil))) ;
    T = t(x, t(x, nil, nil), t(x, t(x, nil, nil), nil)) ;
    etc......No

**4.03 (\*\*) Симметричные бинарные деревья**  
Будем называть бинарное дерево симметричным, если вы можете провести вертикальную линию через родительский узел, 
и правое поддерево будет зеркальным отражением левого поддерева. 

Напишите предикат symmetric/1 для проверки, является ли данное бинарное дерево симметричным. 

Подсказка: Сначала напишите предикат mirror/2 для проверки, является ли одно дерево зеркальным отображением другого. 
В данной задаче нас интересует только структура, а не содержимое узлов.  

**4.04 (\*\*) Двоичные деревья поиска (словари)**  
Используйте метод add/3, разработанный в главе 4 данного курса (имеется ввиду курс по Прологу, к которому прилагался данный задачник), 
для написания метода, строящего двоичное дерево поиска из списка целых чисел.  
Пример:

    ?- construct([3,2,5,7,1],T).
    T = 
        t(
            3, 
            t(
                2, 
                t(1, nil, nil), 
                nil
            ), 
            t(
                5, 
                nil, 
                t(7, nil, nil)
            )
        )

После этого используйте разработанный метод для проверки решения задачи P56.  
Пример:

    ?- test_symmetric([5,3,18,1,4,12,21]).
    Yes
    ?- test_symmetric([3,2,5,7,4]).
    No

**4.05 (\*\*) Подход Generate-and-test (сгенерируй и проверь)**  
Примените generate-and-test (сгенерируй и проверь) подход 
для построения всех симметричных, полностью сбалансированных деревьев с заданным количеством узлов.  
Пример:

    ?- sym_cbal_trees(5,Ts).
    Ts = 
        [
            t(  
                x, 
                t(
                    x, 
                    nil, 
                    t(x, nil, nil)
                ), 
                t(
                    x, 
                    t(x, nil, nil), 
                    nil
                )
            ), 
            t(
                x, 
                t(
                    x, 
                    t(x, nil, nil), 
                    nil
                ), 
                t(
                    x, 
                    nil, 
                    t(x, nil, nil)
                )
            )
        ]

Сколько таких деревьев будет для количества узлов 57? 
Исследуйте, сколько различных решений будет для заданного количества узлов. 
Что если количество чётное? 
Напишите метод sym_cbal_trees. 

**4.06 (\*\*) Постройте сбалансированное по высоте двоичное дерево (АВЛ-дерево)**  
В сбалансированном по высоте двоичном дереве для всех узлов выполняется следующее условие:  
Высота левого и правого поддеревьев практически одинакова, что значит, их разница не может быть больше одного.  

Напишите метод hbal_tree/2 для построения АВЛ-дерева заданной высоты. 
Метод должен возвращать все возможные варианты построения. 
Поместите символ 'x' в качестве значения во все узлы дерева.  
Пример:

    ?- hbal_tree(3,T).
    T = t(x, t(x, t(x, nil, nil), t(x, nil, nil)), t(x, t(x, nil, nil), t(x, nil, nil))) ;
    T = t(x, t(x, t(x, nil, nil), t(x, nil, nil)), t(x, t(x, nil, nil), nil)) ;
    etc......No

**4.07 (\*\*) Постройте АВЛ-дерево с заданным количеством узлов**  
Рассмотрим АВЛ дерево высотой H. Какое максимальное количество узлов оно может содержать? 
Очевидно, что MaxN = 2**H - 1. 
Тогда, какое будет минимальное количество узлов MinN? Этот вопрос более сложный.   

Попытайтесь найти рекурсивный алгоритм и реализовать его как метод minNodes/2 со следующей сигнатурой:

    % minNodes(H,N)  , где N  - это минимальное количество узлов АВЛ-дерева H. 
    (integer,integer), (+,?)

С другой стороны, мы можем спросить: какова будет максимальная высота H для АВЛ-дерева, имеющего N узлов?  

    % maxHeight(N,H) , где H - максимальная высота АВЛ-дерева с N узлами.
    (integer,integer), (+,?)

Теперь мы готовы решать основную проблему: построение всех АВЛ-деревьев с заданным количеством узлов. 

    % hbal_tree_nodes(N,T) :- T is a height-balanced binary tree with N nodes.

Определите, сколько АВЛ-деревьев существует для N = 15.  

**4.08 (\*) Посчитать листья бинарного дерева**  
Лист - это узел без потомков. 
Напишите метод count_leaves/2, считающий листья дерева.

    % count_leaves(T,N) , где бинарное дерево T имеет N листьев.

**4.09 (\*) Соберите листья бинарного дерева в список**  
Лист - это узел без потомков. 
Напишите метод leaves/2 для сбора листьев дерева в список.  

    % leaves(T,S) , где S - это список всех листьев бинарного дерева T.

**4.10 (\*) Соберите все внутренние узлы бинарного дерева в список**  
Внутренний узел бинарного дерева имеет один или два непустых потомка. 
Напишите предикат internals/2 для сбора внутренних узлов в список. 

    % internals(T,S) , где S - это список всех внутренних узлов бинарного дерева T.

**4.11 (\*) Соберите узлы заданного уровня в список**  
Узел бинарного дерева находится на уровне N, если путь от родительского узла до данного узла имеет длину N-1. 
Родительский элемент находится на уровне 1. 
Напишите метод atlevel/3 для сборки всех узлов выбранного уровня в список.  

    % atlevel(T,L,S) , где S - это список узлов бинарного дерева T, которые находятся на уровне L.

Используя метод atlevel/3 легко разработать метод levelorder/2, который создаёт упорядоченную по уровню последовательность узлов. 
При этом, существуют более эффективные способы реализации данного метода.  

**4.12 (\*\*) Построить полное бинарное дерево**  
Полное бинарное дерево высоты H определяется следующим образом:  
Уровни 1,2,3,...,H-1 содержат максимальное количество узлов (то есть 2^(i-1) на уровне i, при этом считать мы считаем с 1 от корня). 
На уровне H допустимо иметь меньше, чем максимально возможное количество узлов. На этом уровне все узлы "выровнены по левому краю". 
Это означает, что при поуровневом обходе дерева (обходе в ширину) все внутренние узлы будут встречаться на пути первыми, потом будут идти листья, 
а пустые потомки (узлы типа nil на самом деле не являются полноценными узлами!) идут последними.  

На практике полные бинарные деревья используются в качестве структур данных (или схем адресации) для куч.  

Мы можем назначить номерной адрес каждому узлу в полном бинарном дереве, поочерёдно перечисляя узлы при поуровневом обходе дерева, 
начиная с корня со значения 1.  

Делая так становится очевидно, что для каждого узла X c адресом A будет истинно следующее утверждение: 
Адреса левых и правых потомков - 2*A and 2*A+1 соответственно (с условием, что потомки существуют). 
Этот факт может быть использован для написания элегантного алгоритма построения полного бинарного дерева.   

Напишите метод complete_binary_tree/2, имеющий следующую спецификацию: 

    % complete_binary_tree(N,T) , где T - полное бинарное дерево, имеющее N узлов. (+,?)

Как следует протестируйте свой метод.  

**4.13 (\*\*) Отрисовка бинарного дерева (1)**  
Дано бинарное дерево t(X,L,R) (или nil). 
В подготовительной части алгоритм отрисовки должен определить позицию каждого узла на прямоугольной сетке.  
Существует несколько методов отрисовки, один из них показан на иллюстрации ниже. 
![alt text](https://github.com/schastny/p99/raw/master/img/p64.gif)

В данном методе, позиция узла v вычисляется по следующим правилам:  
- x(v) равняется порядковому номеру узла v при симметричном обходе (inorder tree traversal, см. [Tree_traversal](http://en.wikipedia.org/wiki/Tree_traversal))
- y(v) равняется глубине узла v в последовательности дерева (is equal to the depth of the node v in the tree sequence)

Для того, чтобы хранить позицию узлов, мы расширим понятие узел следующим образом: 

    % nil - пустое дерево (как обычно)
    % t(W,X,Y,L,R) - непустое бинарное дерево с родительским узлом W, имеющем позицию (X,Y), и поддеревьями L и R

Напишите метод layout_binary_tree/2 со следующей спецификацией:

    % layout_binary_tree(T,PT) , где PT - "позиционированное" бинарное дерево, полученное из бинарного дерева T. (+,?)

Как следует протестируйте свой метод.  

**4.14 (\*\*) Отрисовка бинарного дерева (2)**  
Альтернативный подход к отрисовке изображён на иллюстрации ниже.   
![alt text](https://github.com/schastny/p99/raw/master/img/p65.gif)

Определите правила данной отрисовки и напишите метод, их реализовывающий.   
Подсказка: Для каждого уровня узлов горизонтальное расстояние между соседними узлами является константой.  

Используйте те же соглашения, как и в задачах 4.13. 
Как следует протестируйте свой метод.  

**4.15 (\*\*\*) Отрисовка бинарного дерева (3)**  
Ещё один способ отрисовки показан на рисунке ниже.  
![alt text](https://github.com/schastny/p99/raw/master/img/p66.gif)

Данный способ позволяет рисовать дерево очень компактно, при этом удерживая симметрию в каждом узле. 
Определите правила данной отрисовки и напишите метод, их реализовывающий.  
Подсказка: Обратите внимание на горизонтальное расстояние между узлом и его потомками.  

Как плотно вы можете уместить два поддерева для отрисовки комбинированного бинарного дерева? 
Используйте те же соглашения, как и в задачах 4.13 и 4.14. 
Как следует протестируйте свой метод.  

Примечание: Это достаточно сложное задание. Не сдавайтесь слишком рано!  

Какой метод отрисовки вам понравился больше всего?  

**4.16 (\*\*) Строчное представление бинарных деревьев**  
Некоторые изображают бинарные деревья как строку следующего типа (смотри пример):

    a(b(d,e),c(,f(g,)))

a) Напишите метод, генерирующий строчное представление для дерева, предоставленного в обычном виде (как nil или как t(X,L,R)). 
Потом напишите метод, который делает обратное действие, то есть для заданного строчного представления строит дерево. 
В заключение, сведите два метода в один tree_string/2, который можно использовать в обоих направлениях.  

b) 
Напишите этот же метод (tree_string/2), используя [difference lists](http://en.wikibooks.org/wiki/Prolog/Difference_Lists) и метод tree_dlist/2, 
который делает преобразование из дерева в difference list и наоборот в обоих направлениях.  

Для простоты сделайте допущение, что информация в узлах - это единичный символ, и в строчном представлении дерева нет пробелов.  

**4.17 (\*\*) Симметричный (inorder) и в ширину (preorder) обходы бинарных деревьев**  
Мы рассматриваем бинарные деревья с узлами, которые в качестве значений содержат единичные символы, так же, как и в задаче 4.16.  

a) Напишите методы preorder/2 и inorder/2, 
которые строят симметричную (inorder) и в ширину (preorder) последовательности обхода для заданного бинарного дерева. 
Результатом должен быть атом, то есть 'abdecfg' для последовательности обхода в ширину, вычисленной для примера из задачи 4.16.  

b) Сможете ли вы использовать метод preorder/2 из пункта а) этого задания для выполнения обратного действия? 
То есть, для заданной последовательности обхода в ширину, построить соответствующее дерево. 
Обновите метод по необходимости для достижения этой цели.  

c) Если обе последовательности (preorder и inorder) заданы, тогда можно однозначно (недвусмысленно) определить бинарное дерево. 
Напишите метод pre_in_tree/3 который делает эту работу.  

d) Решите задания a), b) и c) с использованием difference lists. 
Используйте предопределённый метод time/1 для сравнения результатов.  

Что случится, если один и тот же символ возникнет в последовательности больше одного раза? 
Например, попытайтесь запустить следующий код:

    pre_in_tree(aba,baa,T).

**4.18 (\*\*) Точечное строчное представление бинарных деревьев**  
Опять мы рассматриваем бинарные деревья с узлами, которые в качестве значений содержат единичные символы, так же, как и в задаче 4.16. 
Такие деревья могут быть представлены preorder последовательностью обхода узлов, в которой точки (.) будут обозначать пустые поддеревья (nil). 
Например, дерево из задачи 4.16 можно записать в виде
 
    'abd..e..c.fg...'

В первую очередь попытайтесь определить синтаксис ([BNF](http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form) или [синтаксические диаграммы](http://en.wikipedia.org/wiki/Syntax_diagram)) 
а потом напишите метод tree_dotstring/2, который будет делать преобразование в обоих направлениях. 
Используйте difference lists.

[Предыдущая глава](logic.md) | [Оглавление](README.md) | [Следующая глава](multiwaytrees.md)