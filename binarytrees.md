##Бинарные деревья

Бинарное дерево является либо пустым, либо состоит из родительского узла и двух потомков, являющихся также бинарными деревьями. 
В Прологе мы представляем пустое дерево термином 'nil', а непустое - t(X,L,R), 
где X - родительский узел, L и R - левый и правый наследники. 

![alt text](https://github.com/schastny/p99/raw/master/img/p67.gif)
Приведённое на картинке дерево может быть представлено следующей записью:    

    T1 = 
        t(
            a, 
            t(
                b, 
                t(d, nil, nil), 
                t(e, nil, nil)
            ), 
            t(  
                c, 
                nil, 
                t(
                    f, 
                    t(g, nil, nil), 
                    nil
                )
            )
        )

Другой пример - бинарное дерево, состоящее только из родительского узла:  

    T2 = t(a,nil,nil) 

или пустое дерево:

    T3 = nil

**4.01 (\*) 
Проверить, является ли данный объект бинарным деревом**  
Напишите предикат istree/1, который возвращает true только в том случае, если его аргумент - это бинарное дерево.  
Пример:

    ?- istree(t(a,t(b,nil,nil),nil)).
    Yes
    ?- istree(t(a,t(b,nil,nil))).
    No

**4.02 (\*\*) Построить сбалансированное двоичное дерево**  
В полностью сбалансированном двоичном дереве для всех узлов выполняется следующее условие:  
Количество узлов в левом и правом поддеревьях практически одинаково, 
что значит, их разница не может быть больше одного.  

Напишите метод cbal_tree/2 для построения полностью сбалансированного дерева с заданным количеством узлов. 
Метод должен возвращать все возможные варианты построения. 
Поместите символ 'x' в качестве значения во все узлы дерева.    
Пример:

    ?- cbal_tree(4,T).
    T = t(x, t(x, nil, nil), t(x, nil, t(x, nil, nil))) ;
    T = t(x, t(x, nil, nil), t(x, t(x, nil, nil), nil)) ;
    etc......No

**4.03 (\*\*) Симметричные бинарные деревья**  
Будем называть бинарное дерево симметричным, если вы можете провести вертикальную линию через родительский узел, 
и правое поддерево будет зеркальным отражением левого поддерева. 

Напишите предикат symmetric/1 для проверки, является ли данное бинарное дерево симметричным. 

Подсказка: Сначала напишите предикат mirror/2 для проверки, является ли одно дерево зеркальным отображением другого. 
В данной задаче нас интересует только структура, а не содержимое узлов.  

**4.04 (\*\*) Двоичные деревья поиска (словари)**  
Используйте метод add/3, разработанный в главе 4 данного курса (имеется ввиду курс по Прологу, к которому прилагался данный задачник), 
для написания метода, строящего двоичное дерево поиска из списка целых чисел.  
Пример:

    ?- construct([3,2,5,7,1],T).
    T = 
        t(
            3, 
            t(
                2, 
                t(1, nil, nil), 
                nil
            ), 
            t(
                5, 
                nil, 
                t(7, nil, nil)
            )
        )

После этого используйте разработанный метод для проверки решения задачи P56.  
Пример:

    ?- test_symmetric([5,3,18,1,4,12,21]).
    Yes
    ?- test_symmetric([3,2,5,7,4]).
    No

**4.05 (\*\*) Подход Generate-and-test (сгенерируй и проверь)**  
Примените generate-and-test (сгенерируй и проверь) подход 
для построения всех симметричных, полностью сбалансированных деревьев с заданным количеством узлов.  
Пример:

    ?- sym_cbal_trees(5,Ts).
    Ts = 
        [
            t(  
                x, 
                t(
                    x, 
                    nil, 
                    t(x, nil, nil)
                ), 
                t(
                    x, 
                    t(x, nil, nil), 
                    nil
                )
            ), 
            t(
                x, 
                t(
                    x, 
                    t(x, nil, nil), 
                    nil
                ), 
                t(
                    x, 
                    nil, 
                    t(x, nil, nil)
                )
            )
        ]

Сколько таких деревьев будет для количества узлов 57? 
Исследуйте, сколько различных решений будет для заданного количества узлов. 
Что если количество чётное? 
Напишите метод sym_cbal_trees. 

**4.06 (\*\*) Постройте сбалансированное по высоте двоичное дерево (АВЛ-дерево)**  
В сбалансированном по высоте двоичном дереве для всех узлов выполняется следующее условие:  
Высота левого и правого поддеревьев практически одинакова, что значит, их разница не может быть больше одного.  

Напишите метод hbal_tree/2 для построения АВЛ-дерева заданной высоты. 
Метод должен возвращать все возможные варианты построения. 
Поместите символ 'x' в качестве значения во все узлы дерева.  
Пример:

    ?- hbal_tree(3,T).
    T = t(x, t(x, t(x, nil, nil), t(x, nil, nil)), t(x, t(x, nil, nil), t(x, nil, nil))) ;
    T = t(x, t(x, t(x, nil, nil), t(x, nil, nil)), t(x, t(x, nil, nil), nil)) ;
    etc......No

**4.07 (\*\*) Постройте АВЛ-дерево с заданным количеством узлов**  
Рассмотрим АВЛ дерево высотой H. Какое максимальное количество узлов оно может содержать? 
Очевидно, что MaxN = 2**H - 1. 
Тогда, какое будет минимальное количество узлов MinN? Этот вопрос более сложный.   

Попытайтесь найти рекурсивный алгоритм и реализовать его как метод minNodes/2 со следующей сигнатурой:

    % minNodes(H,N)  , где N  - это минимальное количество узлов АВЛ-дерева H. 
    (integer,integer), (+,?)

С другой стороны, мы можем спросить: какова будет максимальная высота H для АВЛ-дерева, имеющего N узлов?  

    % maxHeight(N,H) , где H - максимальная высота АВЛ-дерева с N узлами.
    (integer,integer), (+,?)

Теперь мы готовы решать основную проблему: построение всех АВЛ-деревьев с заданным количеством узлов. 

    % hbal_tree_nodes(N,T) :- T is a height-balanced binary tree with N nodes.

Определите, сколько АВЛ-деревьев существует для N = 15.  

**4.08 (\*) Посчитать листья бинарного дерева**  
Лист - это узел без потомков. 
Напишите метод count_leaves/2, считающий листья дерева.

    % count_leaves(T,N) , где бинарное дерево T имеет N листьев.

**4.09 (\*) Соберите листья бинарного дерева в список**  
Лист - это узел без потомков. 
Напишите метод leaves/2 для сбора листьев дерева в список.  

    % leaves(T,S) , где S - это список всех листьев бинарного дерева T.

**4.10 (\*) Соберите все внутренние узлы бинарного дерева в список**  
Внутренний узел бинарного дерева имеет один или два непустых потомка. 
Напишите предикат internals/2 для сбора внутренних узлов в список. 

    % internals(T,S) , где S - это список всех внутренних узлов бинарного дерева T.

**4.11 (\*) Соберите узлы заданного уровня в список**  
Узел бинарного дерева находится на уровне N, если путь от родительского узла до данного узла имеет длину N-1. 
Родительский элемент находится на уровне 1. 
Напишите метод atlevel/3 для сборки всех узлов выбранного уровня в список.  

    % atlevel(T,L,S) , где S - это список узлов бинарного дерева T, которые находятся на уровне L.

Используя метод atlevel/3 легко разработать метод levelorder/2, который создаёт упорядоченную по уровню последовательность узлов. 
При этом, существуют более эффективные способы реализации данного метода.  

**4.12 (\*\*) Построить полное бинарное дерево**  
Полное бинарное дерево высоты H определяется следующим образом:  
Уровни 1,2,3,...,H-1 содержат максимальное количество узлов (то есть 2^(i-1) на уровне i, при этом считать мы считаем с 1 от корня). 
На уровне H допустимо иметь меньше, чем максимально возможное количество узлов. На этом уровне все узлы "выровнены по левому краю". 
Это означает, что при поуровневом обходе дерева (обходе в ширину) все внутренние узлы будут встречаться на пути первыми, потом будут идти листья, 
а пустые потомки (узлы типа nil на самом деле не являются полноценными узлами!) идут последними.  

На практике полные бинарные деревья используются в качестве структур данных (или схем адресации) для куч.  

Мы можем назначить номерной адрес каждому узлу в полном бинарном дереве, поочерёдно перечисляя узлы при поуровневом обходе дерева, 
начиная с корня со значения 1.  

Делая так становится очевидно, что для каждого узла X c адресом A будет истинно следующее утверждение: 
Адреса левых и правых потомков - 2*A and 2*A+1 соответственно (с условием, что потомки существуют). 
Этот факт может быть использован для написания элегантного алгоритма построения полного бинарного дерева.   

Напишите метод complete_binary_tree/2, имеющий следующую спецификацию: 

    % complete_binary_tree(N,T) , где T - полное бинарное дерево, имеющее N узлов. (+,?)

Как следует протестируйте свой метод.  

**4.13 (\*\*) Отрисовка бинарного дерева (1)**  
Дано бинарное дерево t(X,L,R) (или nil). 
В подготовительной части алгоритм отрисовки должен определить позицию каждого узла на прямоугольной сетке.  
Существует несколько методов отрисовки, один из них показан на иллюстрации ниже. 
![alt text](https://github.com/schastny/p99/raw/master/img/p64.gif)

В данном методе, позиция узла v вычисляется по следующим правилам:  
- x(v) равняется положению узла v inorder в (is equal to the position of the node v in the inorder)
- y(v) равняется глубине узла v в последовательности дерева (is equal to the depth of the node v in the tree sequence)

Для того, чтобы хранить позицию узлов, мы расширим понятие узел следующим образом: 

    % nil - пустое дерево (как обычно)
    % t(W,X,Y,L,R) - непустое бинарное дерево с родительским узлом W, имеющем позицию (X,Y), и поддеревьями L и R

Напишите метод layout_binary_tree/2 со следующей спецификацией:

    % layout_binary_tree(T,PT) , где PT - "позиционированное" бинарное дерево, полученное из бинарного дерева T. (+,?)

Как следует протестируйте свой метод.  

**4.14 (\*\*) Отрисовка бинарного дерева (2)**  
Альтернативный подход к отрисовке изображён на иллюстрации ниже.   
![alt text](https://github.com/schastny/p99/raw/master/img/p65.gif)

Определите правила данной отрисовки и напишите метод, их реализовывающий.   
Подсказка: Для каждого уровня узлов горизонтальное расстояние между соседними узлами является константой.  

Используйте те же соглашения, как и в задачах 4.13. 
Как следует протестируйте свой метод.  

**4.15 (\*\*\*) Отрисовка бинарного дерева (3)**  
Ещё один способ отрисовки показан на рисунке ниже.  
![alt text](https://github.com/schastny/p99/raw/master/img/p66.gif)

Данный способ позволяет рисовать дерево очень компактно, при этом удерживая симметрию в каждом узле. 
Определите правила данной отрисовки и напишите метод, их реализовывающий. 
Подсказка: Обратите внимание на горизонтальное расстояние между узлом и его потомками.  

Как плотно вы можете уместить два поддерева для отрисовки комбинированного бинарного дерева?  

Используйте те же соглашения, как и в задачах 4.13 и 4.14. 
Как следует протестируйте свой метод.  

Примечание: Это достаточно сложное задание. Не сдавайтесь слишком рано!  

Какой метод отрисовки вам понравился больше всего?  

**4.16 (\*\*) A string representation of binary trees**  
Somebody represents binary trees as strings of the following type (see example):

    a(b(d,e),c(,f(g,)))

a) Write a Prolog predicate which generates this string representation, if the tree is given as usual (as nil or t(X,L,R) term). 
Then write a predicate which does this inverse; i.e. given the string representation, construct the tree in the usual form. 
Finally, combine the two predicates in a single predicate tree_string/2 which can be used in both directions.

b) Write the same predicate tree_string/2 using difference lists and a single predicate tree_dlist/2 
which does the conversion between a tree and a difference list in both directions.

For simplicity, suppose the information in the nodes is a single letter and there are no spaces in the string.

**4.17 (\*\*) Preorder and inorder sequences of binary trees**  
We consider binary trees with nodes that are identified by single lower-case letters, as in the example of problem 4.16.

a) Write predicates preorder/2 and inorder/2 that construct the preorder and inorder sequence of a given binary tree, respectively. 
The results should be atoms, e.g. 'abdecfg' for the preorder sequence of the example in problem 4.16.

b) Can you use preorder/2 from problem part a) in the reverse direction; i.e. given a preorder sequence, construct a corresponding tree? 
If not, make the necessary arrangements.

c) If both the preorder sequence and the inorder sequence of the nodes of a binary tree are given, then the tree is determined unambiguously. 
Write a predicate pre_in_tree/3 that does the job.

d) Solve problems a) to c) using difference lists. Cool! Use the predefined predicate time/1 to compare the solutions.

What happens if the same character appears in more than one node. 
Try for instance pre_in_tree(aba,baa,T).

**4.18 (\*\*) Dotstring representation of binary trees**  
We consider again binary trees with nodes that are identified by single lower-case letters, as in the example of problem 4.16. 
Such a tree can be represented by the preorder sequence of its nodes 
in which dots (.) are inserted where an empty subtree (nil) is encountered during the tree traversal. 
For example, the tree shown in problem 4.16 is represented as 'abd..e..c.fg...'. 
First, try to establish a syntax (BNF or syntax diagrams) and then write a predicate tree_dotstring/2 
which does the conversion in both directions. Use difference lists.

[Предыдущая глава](logic.md) | [Оглавление](README.md) | [Следующая глава](multiwaytrees.md)