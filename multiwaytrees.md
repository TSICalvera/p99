##N-арные деревья (Multiway Trees)

![alt text](https://github.com/schastny/p99/raw/master/img/p70.gif)
N-арное дерево состоит из узлового элемента и (возможно) набора потомков, которые в свою очередь также являются N-арными деревьями. 
N-арное дерево никогда не может быть пустым. Набор потомков часто называют лесом.  

В Прологе N-арное дерево записывают термином t(X,F), 
где X - узловой элемент, а F - лес потомков (список в Прологе).  
Приведённое на картинке дерево может быть представлено следующей записью:  

    T = 
        t(
            a, 
            [
                t(
                    f, 
                    [
                        t(g, [])
                    ]
                ), 
                t(  c, 
                    []
                ), 
                t(
                    b, 
                    [
                        t(d, []), 
                        t(e, [])
                    ]
                )
            ]
        )

**5.01 (\*) Проверить, является ли данный объект N-арным деревом**  
Напишите предикат istree/1, который возвращает true только в том случае, если его аргумент - это N-арное дерево.  
Пример:

    ?- istree(t(a,[t(f,[t(g,[])]),t(c,[]),t(b,[t(d,[]),t(e,[])])])).
    Yes

**5.02 (\*) Посчитать количество узлов N-арного дерева**  
Напишите метод nnodes/1 для подсчёта узлов N-арного дерева.  
Пример:

    ?- nnodes(t(a,[t(f,[])]),N).
    N = 2

Напишите ещё одну версию метода, который позволял бы реализовать flow pattern (o,i) 
(Write another version of the predicate that allows for a flow pattern (o,i)).

**5.03 (\*\*) Построение дерева из строки**  
![alt text](https://github.com/schastny/p99/raw/master/img/p70.gif)
Мы предполагаем, что узлы N-арного дерева содержат в качестве значения единичные символы. 
В посделовательности, полученной при обходе дерева в глубину (depth-first), используется специальный символ ^, 
который обозначает переход предыдущий уровень при обходе.  

Следуя этим правилам, дерево, изображённое на картинке, может быть представлено как строка: 

    afg^^c^bd^e^^^

Определите синтаксис строки и напишите метод tree(String,Tree) для построения дерева по заданной строке. 
Сделайте так, чтобы ваш метод смог работать в обоих направлениях.  

**5.04 (\*) Опередлить длину внутренних путей дерева**  
Длиной внутренних путей N-арного дерева назовём общую длину всех путей от узлового элемента до узлов дерева. 
По этому определению, дерево с диаграммы к задаче 5.03 имеет длину внутренних путей, равную 9.  

Напишите метод ipl(Tree,IPL) для подсчёта длины внутренних путей (+,-).  
(Write a predicate ipl(Tree,IPL) for the flow pattern (+,-))

**5.05 (\*) Построить последовательность обхода в глубину (bottom-up postorder) узлов дерева**  
Напишите метод bottom_up(Tree,Seq), строящий последовательность обхода узлоов в глубину для заданного N-арного дерева Tree. 
Результат Seq должен быть списком.  

Что случится, если вы запустите ваш метод задом наперёд? 

**5.06 (\*\*) Lisp-like tree representation**  
В Лиспе есть определённая нотация для N-арных деревьев. 
Лисп - это выдающийся функциональный язык, который преимущественно используется для задач, связнных с искусственным интеллектом. 
Так что он является одним из главных конкурентов Пролога. 
В Лиспе практически всё является списком, так же, как в Прологе всё есть термин (term).  

Следующая картинка иллюстрирует, как N-арные деревья представленны в Лиспе.  
![alt text](https://github.com/schastny/p99/raw/master/img/p73.png)  

Отметьте, что в лисповой нотации узел с потомками всегда является первым элементом списка, за которым идут его дети. 
Лисповое представление N-арных деревьев - это последовательность элементов и скобок (открывающих и закрывающих), 
которые мы в целом будем называть *токенами*. 
Мы можем эту последовательность токенов представить как список в Прологе. 
Например, запись на Лиспе (a (b c)) может быть представлена на Прологе следующим списком:  
 
    ['(', a, '(', b, c, ')', ')']
     
Напишите метод tree_ltl(T,LTL), который будет строить лисповую запись дерева LTL для дерева T, заданного в стандартной для Пролога нотации.  
Пример:

    ?- tree_ltl(t(a,[t(b,[]),t(c,[])]),LTL).
    LTL = ['(', a, '(', b, c, ')', ')']

Второе задание будет интереснее. Попытайтесь переписать метод tree_ltl/2 таким образом, чтобы была возможность делать обратное преобразование: 
Для заданного списка LTL в лисповой нотации, постройте дерево T, записанное в стандартной для Пролога нотации. 
Используйте difference lists.

[Предыдущая глава](binarytrees.md) | [Оглавление](README.md) | [Следующая глава](graphs.md)