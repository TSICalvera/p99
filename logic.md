##Задачи на логику  

**3.01 (\*\*) Таблицы истинности для логических выражений.**  
Определите предикаты and/2, or/2, nand/2, nor/2, xor/2, impl/2 and equ/2 (для определения логической равнозначности), 
Например, and(A,B) должен возвращать 'true' только в том случае, если и A и B true. 
Отметьте, что A и B могут быть выражениями, а не просто константами true и false.  
  
В таком случае логическое выражение из двух переменных можно будет записать префиксной нотацией, как в примере ниже: 

    and(or(A,B),nand(A,B)).  
  
Теперь напишите метод table/3, печатающий таблицу истинности для заданного логического выражения, сотоящего из двух переменных.    
Пример:

    ?- table(A,B,and(A,or(A,B))).
    true true true
    true fail true
    fail true fail
    fail fail fail


**3.02 (\*) Таблицы истинности для логических выражений (2).**  
Модифицируйте результат задачи 3.01, сделайте все предикаты операторами. 
Это позволит писать логические выражения в более понятном виде, как в примере ниже: 

    A and (A or not B). 

Порядок выполнения операций сделайте обычным, например, как в Java.  
Пример:

    ?- table(A,B, A and (A or not B)).
    true true true
    true fail true
    fail true fail
    fail fail fail


**3.03 (\*\*) Truth tables for logical expressions (3).**  
Generalize problem 3.02 in such a way that the logical expression may contain any number of logical variables. 
Define table/2 in a way that table(List,Expr) prints the truth table for the expression Expr, 
which contains the logical variables enumerated in List.

Пример:

    ?- table([A,B,C], A and (B or C) equ A and B or A and C).
    true true true true
    true true fail true
    true fail true true
    true fail fail true
    fail true true true
    fail true fail true
    fail fail true true
    fail fail fail true


**3.04 (\*\*) Код Грея.**  
(http://en.wikipedia.org/wiki/Gray_code)
N-ичный код Грея - это последовательность из строк длины n, построенная по определённым правилам: 
два соседних значения последовательности различаются только в одном разряде.
Например,
    
    n = 1: C(1) = ['0','1'].
    n = 2: C(2) = ['00','01','11','10'].
    n = 3: C(3) = ['000','001','011','010','110','111','101','100'].

Определите правила построения кода и напишите метод со следующей сигнатурой:

    % gray(N,C) , где C - это N-ичный код Грея.

Сможете ли вы применить "кеширование результатов" для того, чтобы сделать метод более эффективным в случае его повторного использования?  

**3.05 (\*\*\*) Huffman code.**  
Прежде всего, почитайте хороший учебник по дискретной математике, описывающий [алгоритм Хаффмана](http://en.wikipedia.org/wiki/Huffman_coding)  

Предположим, у нас имеется набор символов S с частотами из использования F - fr(S,F). 
Пример:
 
    [fr(a,45), fr(b,13), fr(c,12), fr(d,16), fr(e,9), fr(f,5)]. 
    
Наша задача - построить список hc(S,C), где C - это код Хаффмана для символа S.  
В нашем примере результат должен быть такой:

    Hs = 
        [hc(a,'0'), hc(b,'101'), hc(c,'100'), hc(d,'111'), hc(e,'1101'), hc(f,'1100')] 
        [hc(a,'01'),...etc.].
         
Для выполнения задачи нужно создать метод со следующей сигнатурой:  

    % huffman(Fs,Hs) , где Hs - это результирующая таблица кодов Хаффмана, а Fs - исходная таблица частот.  

[Предыдущая глава](arithmetic.md) | [Оглавление](README.md) | [Следующая глава](binarytrees.md)